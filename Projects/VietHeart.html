<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Love Rain Neon</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
    }
    canvas {
      display: block;
    }
    @import url('https://fonts.googleapis.com/css2?family=Mali&display=swap');
  </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://esm.sh/three';
import { EffectComposer } from 'https://esm.sh/three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://esm.sh/three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://esm.sh/three/examples/jsm/postprocessing/UnrealBloomPass.js';

let scene, camera, renderer, composer;
let hearts = [], texts = [], particles;
let heartGeometry, heartMaterial;

let isDragging = false;
let prevMouse = { x: 0, y: 0 };
let rotation = { x: 0, y: 0 };
let zoom = 50;
let zoomTarget = 50;

const messages = [
  "Cảm ơn vì em đã đến",
  "Anh yêu em nhiều lắm ♡",
  "Làm người yêu anh nhé ♡",
  "Em là ánh sáng trong cuộc đời anh",
  "Anh sẽ mãi yêu em",
  "Chúng ta sẽ đi hết cuộc đời này",
    "Em là điều tuyệt vời nhất",
    "Mỗi ngày bên em là một ngày hạnh phúc",
    "Yêu em từ cái nhìn đầu tiên",
    "Em là lý do anh mỉm cười",
    "Cùng nhau tạo nên những kỷ niệm đẹp",
    "Em là món quà quý giá nhất",
    "Anh sẽ luôn bên em, trong mọi hoàn cảnh",
    "Tình yêu của chúng ta sẽ mãi bền vững",
    "Em là người anh muốn dành cả cuộc đời này",
    "Mỗi khoảnh khắc bên em đều đáng trân trọng",
    "Em là lý do anh tin vào tình yêu",
    "Anh sẽ luôn yêu em, dù có chuyện gì xảy ra",
    "Em là người anh muốn cùng xây dựng tương lai",
    "Tình yêu của chúng ta là mãi mãi",
    "Em là người anh muốn cùng đi khắp thế gian",
    "Anh sẽ luôn yêu em, dù thời gian có trôi qua",
    "Em là người anh muốn cùng chia sẻ mọi niềm vui nỗi buồn",
    "Tình yêu của chúng ta là một hành trình đẹp",
    "Em là người anh muốn cùng viết nên câu chuyện tình yêu của chúng ta",
    "Anh sẽ luôn yêu em, dù có bao nhiêu thử thách",
    "Em là người anh muốn cùng khám phá thế giới",
    "Tình yêu của chúng ta là một bản nhạc đẹp",
    "Em là người anh muốn cùng tạo nên những kỷ niệm đáng nhớ",
    "Anh sẽ luôn yêu em, dù có bao nhiêu khó khăn",
    "Em là người anh muốn cùng đi qua mọi thăng trầm của cuộc sống",
    "Tình yêu của chúng ta là một hành trình đầy màu sắc",
    "Em là người anh muốn cùng xây dựng một gia đình hạnh phúc",
    "Anh sẽ luôn yêu em, dù có bao nhiêu khoảng cách",
    "Em là người anh muốn cùng đi đến cuối cuộc đời",
    "Tình yêu của chúng ta là một ngọn lửa không bao giờ tắt",
    "Em là người anh muốn cùng nhau vượt qua mọi thử thách"
];

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = zoom;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const renderScene = new RenderPass(scene, camera);
  const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.4, 0.85);
  bloom.threshold = 0.0;
  bloom.strength = 1.2;
  bloom.radius = 0.5;

  composer = new EffectComposer(renderer);
  composer.addPass(renderScene);
  composer.addPass(bloom);

  addLights();
  prepareHeartGeometry();
  createParticles();

  window.addEventListener('resize', onResize);
  window.addEventListener('wheel', onZoom);
  window.addEventListener('mousedown', (e) => {
    isDragging = true;
    prevMouse.x = e.clientX;
    prevMouse.y = e.clientY;
  });
  window.addEventListener('mouseup', () => isDragging = false);
  window.addEventListener('mousemove', onMouseDrag);
}

function addLights() {
  scene.add(new THREE.AmbientLight(0xffffff, 1));
  const light = new THREE.PointLight(0xff99cc, 1.5, 200);
  light.position.set(0, 30, 50);
  scene.add(light);
}

function prepareHeartGeometry() {
  const shape = new THREE.Shape();
  shape.moveTo(0, 0);
  shape.bezierCurveTo(0, 3, -5, 3, -5, 0);
  shape.bezierCurveTo(-5, -3, 0, -5, 0, -7);
  shape.bezierCurveTo(0, -5, 5, -3, 5, 0);
  shape.bezierCurveTo(5, 3, 0, 3, 0, 0);

  heartGeometry = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false });
  heartMaterial = new THREE.MeshPhongMaterial({ color: 0xff3366, shininess: 300, specular: 0xffccff });
}

function createParticles() {
  const count = 1000;
  const geometry = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  for (let i = 0; i < count * 3; i++) {
    positions[i] = (Math.random() - 0.5) * 400;
  }
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const material = new THREE.PointsMaterial({ color: 0xffaad4, size: 0.8, transparent: true });
  particles = new THREE.Points(geometry, material);
  scene.add(particles);
}

function createTextMesh(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const fontSize = 64;
  canvas.width = 1024;
  canvas.height = 128;
  ctx.font = `bold ${fontSize}px 'Mali', sans-serif`;
  ctx.fillStyle = '#ff99cc';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#ff66aa';
  ctx.shadowBlur = 15;
  ctx.fillText(text, canvas.width / 2, fontSize);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
  const geometry = new THREE.PlaneGeometry(20, 2.5);
  const mesh = new THREE.Mesh(geometry, material);
  return mesh;
}

function spawnText() {
  const message = messages[Math.floor(Math.random() * messages.length)];
  const mesh = createTextMesh(message);
  mesh.position.set((Math.random() - 0.5) * 150, 80 + Math.random() * 40, (Math.random() - 0.5) * 150);
  mesh.rotation.y = Math.random() * Math.PI * 2;
  mesh.userData.velocity = new THREE.Vector3(0, -0.2 - Math.random() * 0.2, 0);
  texts.push(mesh);
  scene.add(mesh);
}

function spawnHeart() {
  const mesh = new THREE.Mesh(heartGeometry, heartMaterial.clone());
  mesh.scale.setScalar(0.2 + Math.random() * 0.3);
  mesh.position.set((Math.random() - 0.5) * 150, 80 + Math.random() * 40, (Math.random() - 0.5) * 150);
  mesh.rotation.set(Math.random(), Math.random(), Math.random());
  mesh.userData.velocity = new THREE.Vector3(0, -0.2 - Math.random() * 0.2, 0);
  hearts.push(mesh);
  scene.add(mesh);
}

function animate(time) {
  requestAnimationFrame(animate);

  if (Math.random() < 0.6) spawnText();
  if (Math.random() < 0.4) spawnHeart();

  hearts.forEach((h, i) => {
    h.position.add(h.userData.velocity);
    h.rotation.y += 0.01;
    if (h.position.y < -80) {
      scene.remove(h);
      hearts.splice(i, 1);
    }
  });

  texts.forEach((t, i) => {
    t.position.add(t.userData.velocity);
    if (t.position.y < -80) {
      scene.remove(t);
      texts.splice(i, 1);
    }
  });

  particles.rotation.y += 0.001;

  camera.position.z += (zoomTarget - camera.position.z) * 0.1;
  camera.rotation.order = 'YXZ';
  camera.rotation.y = rotation.x;
  camera.rotation.x = rotation.y;

  composer.render();
}

function onMouseDrag(e) {
  if (!isDragging) return;
  const deltaX = e.clientX - prevMouse.x;
  const deltaY = e.clientY - prevMouse.y;
  rotation.x += deltaX * 0.005;
  rotation.y += deltaY * 0.005;
  prevMouse.x = e.clientX;
  prevMouse.y = e.clientY;
}

function onZoom(e) {
  zoomTarget += e.deltaY * 0.1;
  if (zoomTarget < 20) zoomTarget = 20;
  if (zoomTarget > 100) zoomTarget = 100;
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
